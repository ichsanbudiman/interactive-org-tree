<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organization Tree - Preview Mode</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        #graph-container {
            width: 100%;
            height: 80vh;
            overflow: auto;
            border: 1px solid #ffffff;
            background-color: #ffffff;
            position: relative;
        }

        #tree-chart {
            min-width: 100%;
        }

        svg {
            overflow: visible;
        }

        .node rect {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 2px;
        }

        .node line {
            stroke: #ccc;
            stroke-width: 1px;
        }

        .node text {
            font-size: 12px;
            fill: #333;
        }

        .link {
            fill: none;
            stroke: #090909;
            stroke-width: 2px;
            cursor: default;
        }

        .drop-zone {
            display: inline-block;
            padding: 10px 20px;
            border: 2px dashed #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
            text-align: center;
        }

        .drop-zone:hover {
            border-color: #4CAF50;
            background-color: #f0f8f0;
        }

        .drop-zone.drag-over {
            border-color: #4CAF50;
            background-color: #e8f5e9;
            transform: scale(1.05);
        }

        #exportPdfBtn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }

        #exportPdfBtn:hover {
            background-color: #d32f2f;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 500px;
            border-radius: 5px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn-submit {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
        }

        .btn-submit:hover {
            background-color: #45a049;
        }
    </style>
</head>

<body>
    <div style="margin-bottom: 10px;">
        <div id="dropZone" class="drop-zone" onclick="document.getElementById('fileInput').click()">
            ðŸ“‚ Drag & Drop JSON File or Click to Browse
        </div>
        <input type="file" id="fileInput" accept=".json,application/json" style="display: none;">
        <button id="exportPdfBtn" onclick="openExportModal()">ðŸ“„ Export to PDF</button>
    </div>
    <div id="graph-container">
        <div id="tree-chart"></div>
    </div>

    <div id="exportModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeExportModal()">&times;</span>
            <h2>Export to PDF</h2>
            <form id="exportForm" onsubmit="handleExport(event)">
                <div class="form-group">
                    <label for="graphName">Graph Name:</label>
                    <input type="text" id="graphName" name="graphName" placeholder="Enter graph name" required>
                </div>
                <div class="form-group">
                    <label for="paperSize">Paper Size:</label>
                    <select id="paperSize" name="paperSize" required>
                        <option value="A4">A4 (210 x 297 mm)</option>
                        <option value="A3">A3 (297 x 420 mm)</option>
                        <option value="A2">A2 (420 x 594 mm)</option>
                        <option value="A1">A1 (594 x 841 mm)</option>
                        <option value="A0">A0 (841 x 1189 mm)</option>
                        <option value="Letter">Letter (8.5 x 11 in)</option>
                        <option value="Legal">Legal (8.5 x 14 in)</option>
                        <option value="Tabloid">Tabloid (11 x 17 in)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="orientation">Orientation:</label>
                    <select id="orientation" name="orientation" required>
                        <option value="portrait">Portrait</option>
                        <option value="landscape" selected>Landscape</option>
                    </select>
                </div>
                <button type="submit" class="btn-submit">Export to PDF</button>
            </form>
        </div>
    </div>

    <script>
        const margin = { top: 40, right: 120, bottom: 40, left: 120 };
        let containerWidth = 2000;
        let containerHeight = 2000;
        const svg = d3.select("#tree-chart")
            .append("svg")
            .attr("width", containerWidth)
            .attr("height", containerHeight)
            .append("g")
            .attr("transform", `translate(${containerWidth / 2}, ${margin.top})`);
        
        function updateContainerSize() {
            if (!root) return;
            
            // Find the bounds of all nodes
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            root.descendants().forEach(d => {
                minX = Math.min(minX, d.x);
                maxX = Math.max(maxX, d.x);
                minY = Math.min(minY, d.y);
                maxY = Math.max(maxY, d.y);
            });
            
            // Calculate required dimensions with padding
            const horizontalPadding = 400; 
            const verticalPadding = 200; 
            
            const requiredWidth = Math.max(4000, (maxX - minX) + horizontalPadding);
            const requiredHeight = Math.max(2000, (maxY - minY) + verticalPadding + margin.top + margin.bottom);
            
            containerWidth = requiredWidth;
            containerHeight = requiredHeight;
            
            const graphCenterX = (minX + maxX) / 2;
            const viewportCenterOffset = containerWidth / 2;
            const translateX = viewportCenterOffset - graphCenterX;
            
            svg.attr("transform", `translate(${translateX}, ${margin.top})`);
            
            d3.select("#tree-chart svg")
                .attr("width", containerWidth)
                .attr("height", containerHeight);
            
            
            setTimeout(() => centerGraphInViewport(), 100);
        }
        
        function centerGraphInViewport() {
            const container = document.getElementById('graph-container');
            if (!container || !root) return;
            
            // Calculate graph bounds
            let minX = Infinity, maxX = -Infinity;
            root.descendants().forEach(d => {
                minX = Math.min(minX, d.x);
                maxX = Math.max(maxX, d.x);
            });
            
            const graphCenterX = (minX + maxX) / 2;
            const svgTransform = svg.attr("transform");
            const translateMatch = svgTransform.match(/translate\(([^,]+)/);
            const currentTranslateX = translateMatch ? parseFloat(translateMatch[1]) : containerWidth / 2;
            
            // Calculate where the graph center is in absolute coordinates
            const graphAbsoluteX = currentTranslateX + graphCenterX;
            
            // Calculate scroll position to center the graph in the viewport
            const containerCenter = container.clientWidth / 2;
            const scrollPosition = graphAbsoluteX - containerCenter;
            
            // Scroll to center
            container.scrollLeft = Math.max(0, scrollPosition);
            container.scrollTop = 0;
        }

        const linkControls = new Map();
        let treeData;
        let root;
        let links;
        const tree = d3.tree().nodeSize([180, 150]);

        function getLinkKey(link) {
            return `${link.source.data.nodeid}-${link.target.data.nodeid}`;
        }

        function initializeTree(data) {
            treeData = data;
            root = d3.hierarchy(treeData);
            tree(root);
            
            root.descendants().forEach(d => {
                if (d.data.x === undefined && d.data.y === undefined) {
                    if (d.depth === 0) {
                        d.x = 0;
                        d.y = margin.top;
                    } else if (d.parent) {
                    const siblings = d.parent.children || [];
                    const siblingIndex = siblings.indexOf(d);

                    const siblingSpacing = 300;
                        const verticalSpacing = 150;
                    const totalWidth = (siblings.length - 1) * siblingSpacing;

                        if (d.parent.x === undefined || d.parent.y === undefined) {
                            if (d.parent.depth === 0) {
                                d.parent.x = containerWidth / 16;
                                d.parent.y = margin.top;
                            } else if (d.parent.parent) {
                                const parentSiblings = d.parent.parent.children || [];
                                const parentSiblingIndex = parentSiblings.indexOf(d.parent);
                                const parentTotalWidth = (parentSiblings.length - 1) * siblingSpacing;
                                const parentLeftStart = d.parent.parent.x - parentTotalWidth / 2;
                                d.parent.x = parentLeftStart + parentSiblingIndex * siblingSpacing;
                                d.parent.y = d.parent.parent.y + verticalSpacing;
                            }
                        }

                    const leftStart = d.parent.x - totalWidth / 2;

                    d.x = leftStart + siblingIndex * siblingSpacing;
                        d.y = d.parent.y + verticalSpacing;
                    }
                } else {
                    d.x = d.data.x;
                    d.y = d.data.y;
                }
            });
            
            renderLinks(root);
            renderNodes(root);
            svg.selectAll(".link").lower();
            
            updateContainerSize();
        }

        function renderNodes(root) {
            maxNodeHeight = 60;
            const nodeSelection = svg.selectAll(".node")
                .data(root.descendants(), d => d.data.nodeid);
            
            nodeSelection.exit().remove();
            
            const nodes = nodeSelection.enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .merge(nodeSelection)
                .attr("transform", d => `translate(${d.x},${d.y})`);

            nodes.filter(d => d.data.type === "rectangle")
                .selectAll("rect, text, line").remove();

            nodes.filter(d => d.data.type === "rectangle")
                .each(function (d) {
                    const nameParts = d.data.name.split("\n");
                    const tempText = svg.append("text")
                        .style("font-size", "12px")
                        .style("visibility", "hidden")
                        .text(nameParts.join(" "));

                    const textWidth = tempText.node().getBBox().width;
                    const textHeight = tempText.node().getBBox().height * nameParts.length;

                    tempText.remove();

                    const padding = 20;
                    const minWidth = 150;
                    const rectWidth = Math.max(textWidth + padding, minWidth);

                    const rectHeight = maxNodeHeight; 
                    d3.select(this)
                        .append("rect")
                        .attr("width", rectWidth)
                        .attr("height", rectHeight)
                        .attr("x", -rectWidth / 2)
                        .attr("y", -rectHeight / 2)
                        .style("fill", "#fff")
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    nameParts.forEach((line, index) => {
                        d3.select(this)
                            .append("text")
                            .attr("dx", 0)
                            .attr("dy", -rectHeight / 2 + 15 + index * 15)
                            .attr("text-anchor", "middle")
                            .text(line)
                            .style("font-size", "12px")
                            .style("fill", "#333");
                    });

                    d3.select(this)
                        .append("line")
                        .attr("x1", -rectWidth / 2)
                        .attr("y1", -rectHeight / 2 + textHeight + 10)
                        .attr("x2", rectWidth / 2)
                        .attr("y2", -rectHeight / 2 + textHeight + 10)
                        .style("stroke", "black")
                        .style("stroke-width", 1);

                    d3.select(this)
                        .append("text")
                        .attr("dx", 0)
                        .attr("dy", -rectHeight / 2 + textHeight + 25)
                        .attr("text-anchor", "middle")
                        .text(`(${d.data.class})`)
                        .style("font-size", "12px")
                        .style("fill", "#333");
                });

            nodes.filter(d => d.data.type === "table")
                .selectAll("foreignObject").remove();
                
            nodes.filter(d => d.data.type === "table")
                .each(function(d) {
                })
                .append("foreignObject")
                .attr("width", 320)
                .attr("height", d => d.data.tableData.length * 30 + 40)
                .attr("x", -160)
                .attr("y", -40)
                .append("xhtml:div")
                .style("width", "100%")
                .style("height", "100%")
                .style("box-sizing", "border-box")
                .style("background", "#fff")
                .style("padding", "0")
                .html(d => {
                    const headerRow = `
            <tr>
                <th style="border: 1px solid #000; padding: 5px; text-align: center;">Name</th>
                <th style="border: 1px solid #000; padding: 5px; text-align: center;">Class</th>
                <th style="border: 1px solid #000; padding: 5px; text-align: center;">K</th>
                <th style="border: 1px solid #000; padding: 5px; text-align: center;">B</th>
            </tr>
        `;
                    const rows = d.data.tableData
                        .map(row => `
                <tr>
                    <td style="border: 1px solid #000; padding: 5px; text-align: left;">${row.name || ''}</td>
                    <td style="border: 1px solid #000; padding: 5px; text-align: left;">${row.class || ''}</td>
                    <td style="border: 1px solid #000; padding: 5px; text-align: center;">${row.k || ''}</td>
                    <td style="border: 1px solid #000; padding: 5px; text-align: center;">${row.b || ''}</td>
                </tr>
            `)
                        .join("");
                    return `
            <table style="border-collapse: collapse; width: 100%; font-size: 12px; background-color: #fff;">
                ${headerRow}
                ${rows}
            </table>`;
                });
        }

        function updateLinks() {
            if (!links) return;

            links.attr("d", d => generatePath(d));
            svg.selectAll(".link").lower();
        }

        function renderLinks(root) {
            svg.selectAll(".link").remove();

            links = svg.selectAll(".link")
                .data(root.links())
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("d", d => {
                    const linkKey = getLinkKey(d);
                    if (!linkControls.has(linkKey)) {
                        linkControls.set(linkKey, []);
                    }
                    return generatePath(d);
                })
                .style("cursor", "default");
            
            svg.selectAll(".link").lower();
        }

        function generatePath(d) {
            const linkKey = getLinkKey(d);
            const controls = linkControls.get(linkKey) || [];

            if (controls.length > 0) {
                let path = `M${d.source.x},${d.source.y}`;

                controls.forEach(cp => {
                    path += ` L${cp.x},${cp.y}`;  // Make the line bend through control points
                });

                path += ` L${d.target.x},${d.target.y}`;
                return path;
            } else {
                const midY = (d.source.y + d.target.y) / 2;
                return `M${d.source.x},${d.source.y} 
                V${midY} 
                H${d.target.x} 
                V${d.target.y}`;
            }
        }

        function processFile(file) {
            if (!file) return;
            if (!file.type.includes('json') && !file.name.endsWith('.json')) {
                alert('Please drop a JSON file!');
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                const loadedData = JSON.parse(e.target.result);

                    const savedControlPoints = loadedData.controlPoints || [];
                    
                    const treeDataOnly = { ...loadedData };
                    delete treeDataOnly.controlPoints;

                linkControls.clear();
                svg.selectAll("*").remove();

                    initializeTree(treeDataOnly);
                    
                    root.descendants().forEach(d => {
                        function restorePositions(node, savedNode) {
                            if (node.data.nodeid === savedNode.nodeid) {
                                if (savedNode.x !== undefined && savedNode.y !== undefined) {
                                    node.x = savedNode.x;
                                    node.y = savedNode.y;
                                }
                                
                                if (savedNode.children && node.children) {
                                    savedNode.children.forEach((savedChild, idx) => {
                                        if (node.children[idx]) {
                                            restorePositions(node.children[idx], savedChild);
                                        }
                                    });
                                }
                            }
                        }
                        restorePositions(d, loadedData);
                    });
                    
                    svg.selectAll(".node").remove();
                    renderNodes(root);
                                        
                    if (savedControlPoints && savedControlPoints.length > 0) {
                        savedControlPoints.forEach(cpData => {
                            const linkKey = `${cpData.nodeSourceId}-${cpData.nodeTargetId}`;
                            linkControls.set(linkKey, cpData.controlPoints.map(cp => ({ x: cp.x, y: cp.y })));
                        });
                    }
                    
                    updateLinks();
                    
                    svg.selectAll(".link").lower();

                    console.log("Graph Loaded:", loadedData);
                    alert("Graph Loaded Successfully!");
                } catch (error) {
                    alert("Error loading graph: " + error.message);
                    console.error("Error parsing JSON:", error);
                }
            };
            reader.onerror = function() {
                alert("Error reading file!");
            };
            reader.readAsText(file);
        }

        function loadGraph(event) {
            const file = event.target.files[0];
            processFile(file);
        }

        const dropZone = document.getElementById('dropZone');
        
        dropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        });

        
        document.getElementById('fileInput').addEventListener('change', loadGraph);

        
        window.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        window.addEventListener('drop', function(e) {
            
            if (!e.target.closest('#dropZone')) {
                e.preventDefault();
            }
        });

        
        const initialData = {
            "nodeid": 1,
            "name": "CEO",
            "class": "Executive Level",
            "type": "rectangle",
            "children": [
                {
                    "nodeid": 2,
                    "name": "Chief Financial Officer",
                    "class": "Executive Level",
                    "type": "rectangle",
                    "children": [
                        {
                            "nodeid": 3,
                            "name": "Finance Manager",
                            "class": "Management Level",
                            "type": "rectangle"
                        },
                        {
                            "nodeid": 4,
                            "name": "Accounting Manager",
                            "class": "Management Level",
                            "type": "rectangle"
                        },
                        {
                            "nodeid": 5,
                            "name": "Budget Manager",
                            "class": "Management Level",
                            "type": "rectangle"
                        }
                    ]
                },
                {
                    "nodeid": 6,
                    "name": "Chief Operating Officer",
                    "class": "Executive Level",
                    "type": "rectangle",
                    "children": [
                        {
                            "nodeid": 7,
                            "name": "Operations Manager",
                            "class": "Management Level",
                            "type": "rectangle"
                        },
                        {
                            "nodeid": 8,
                            "name": "Logistics Manager",
                            "class": "Management Level",
                            "type": "rectangle"
                        },
                        {
                            "nodeid": 9,
                            "name": "Quality Manager",
                            "class": "Management Level",
                            "type": "rectangle"
                        }
                    ]
                },
                {
                    "nodeid": 10,
                    "name": "Human Resources Director",
                    "class": "Executive Level",
                    "type": "rectangle"
                },
                {
                    "nodeid": 11,
                    "name": "Chief Technology Officer",
                    "class": "Executive Level",
                    "type": "rectangle"
                },
                {
                    "nodeid": 12,
                    "name": "Chief Marketing Officer",
                    "class": "Executive Level",
                    "type": "rectangle",
                    "children": [
                        {
                            "nodeid": 13,
                            "name": "Marketing Department",
                            "class": "Department",
                            "type": "table",
                            "tableData": [
                                {
                                    "name": "Heru",
                                    "class": "Jabatan 1",
                                    "k": "K1",
                                    "b": "B1"
                                },
                                {
                                    "name": "Yadi",
                                    "class": "Jabatan 2",
                                    "k": "K1",
                                    "b": "B1"
                                },
                                {
                                    "name": "Entis",
                                    "class": "Jabatan 3",
                                    "k": "K1",
                                    "b": "B1"
                                },
                                {
                                    "name": "Asep",
                                    "class": "Jabatan 4",
                                    "k": "K1",
                                    "b": "B1"
                                },
                                {
                                    "name": "Jajang",
                                    "class": "Jabatan 5",
                                    "k": "K2",
                                    "b": "B2"
                                },
                                {
                                    "name": "Cahya",
                                    "class": "Jabatan 6 ",
                                    "k": "K3",
                                    "b": "B3"
                                }
                            ]
                        },
                        {
                            "nodeid": 14,
                            "name": "Sales Manager",
                            "class": "Management Level",
                            "type": "rectangle"
                        }
                    ]
                }
            ]
        };

        // Paper size definitions in mm
        const paperSizes = {
            'A4': { width: 210, height: 297 },
            'A3': { width: 297, height: 420 },
            'A2': { width: 420, height: 594 },
            'A1': { width: 594, height: 841 },
            'A0': { width: 841, height: 1189 },
            'Letter': { width: 215.9, height: 279.4 }, // 8.5 x 11 in to mm
            'Legal': { width: 215.9, height: 355.6 }, // 8.5 x 14 in to mm
            'Tabloid': { width: 279.4, height: 431.8 } // 11 x 17 in to mm
        };

        function openExportModal() {
            document.getElementById('exportModal').style.display = 'block';
            document.getElementById('graphName').value = '';
            document.getElementById('paperSize').value = 'A4';
            document.getElementById('orientation').value = 'landscape';
        }

        function closeExportModal() {
            document.getElementById('exportModal').style.display = 'none';
        }

        function handleExport(event) {
            event.preventDefault();
            const graphName = document.getElementById('graphName').value;
            const paperSize = document.getElementById('paperSize').value;
            const orientation = document.getElementById('orientation').value;
            
            closeExportModal();
            exportToPdf(graphName, paperSize, orientation);
        }

        function exportToPdf(graphName, paperSize, orientation) {
            const { jsPDF } = window.jspdf;
            const svgElement = d3.select("#tree-chart svg").node();
            
            if (!svgElement || !root) {
                alert('No graph to export');
                return;
            }
            
            
            const originalCursor = document.body.style.cursor;
            document.body.style.cursor = 'wait';
            
            
            const paperDimensions = paperSizes[paperSize];
            let pdfWidth = paperDimensions.width;
            let pdfHeight = paperDimensions.height;
            
            
            if (orientation === 'landscape') {
                [pdfWidth, pdfHeight] = [pdfHeight, pdfWidth];
            }
            
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            root.descendants().forEach(d => {
                // Get node bounding box
                const nodeGroup = svg.selectAll(".node").filter(node => node.data.nodeid === d.data.nodeid);
                if (!nodeGroup.empty()) {
                    const nodeElement = nodeGroup.node();
                    if (nodeElement) {
                        const nodeBBox = nodeElement.getBBox();
                        const nodeX = d.x;
                        const nodeY = d.y;
                        
                        // Account for node dimensions
                        const nodeWidth = nodeBBox.width || (d.data.type === 'rectangle' ? 150 : 320);
                        const nodeHeight = nodeBBox.height || (d.data.type === 'rectangle' ? 60 : d.data.tableData ? (d.data.tableData.length * 30 + 40) : 60);
                        
                        minX = Math.min(minX, nodeX - nodeWidth / 2);
                        maxX = Math.max(maxX, nodeX + nodeWidth / 2);
                        minY = Math.min(minY, nodeY - nodeHeight / 2);
                        maxY = Math.max(maxY, nodeY + nodeHeight / 2);
                    } else {
                        
                        minX = Math.min(minX, d.x - 75);
                        maxX = Math.max(maxX, d.x + 75);
                        minY = Math.min(minY, d.y - 30);
                        maxY = Math.max(maxY, d.y + 30);
                    }
                } else {
                    
                    minX = Math.min(minX, d.x - 75);
                    maxX = Math.max(maxX, d.x + 75);
                    minY = Math.min(minY, d.y - 30);
                    maxY = Math.max(maxY, d.y + 30);
                }
            });
            
            
            const graphWidth = maxX - minX;
            const graphHeight = maxY - minY;
            
            
            const padding = 50;
            const graphWidthWithPadding = graphWidth + padding * 2;
            const graphHeightWithPadding = graphHeight + padding * 2;
            
            
            const svgRect = svgElement.getBoundingClientRect();
            const svgWidth = svgElement.getAttribute('width') || svgRect.width;
            const svgHeight = svgElement.getAttribute('height') || svgRect.height;
            
            
            const tempContainer = document.createElement('div');
            tempContainer.style.position = 'absolute';
            tempContainer.style.left = '-9999px';
            tempContainer.style.width = svgWidth + 'px';
            tempContainer.style.height = svgHeight + 'px';
            tempContainer.style.backgroundColor = '#ffffff';
            document.body.appendChild(tempContainer);
            
            
            const svgClone = svgElement.cloneNode(true);
            tempContainer.appendChild(svgClone);
            
            
            html2canvas(tempContainer, {
                backgroundColor: '#ffffff',
                scale: 2, // Higher quality
                logging: false,
                useCORS: true,
                allowTaint: false,
                width: parseInt(svgWidth),
                height: parseInt(svgHeight),
                windowWidth: parseInt(svgWidth),
                windowHeight: parseInt(svgHeight)
            }).then(canvas => {
            
                document.body.removeChild(tempContainer);
                
                const imgData = canvas.toDataURL('image/png');
                
                // Calculate image dimensions in mm (assuming 96 DPI = 37.8 pixels per mm)
                const pixelsPerMm = 37.8;
                
            
                // Convert graph dimensions to mm
                const graphWidthMm = graphWidthWithPadding / pixelsPerMm;
                const graphHeightMm = graphHeightWithPadding / pixelsPerMm;
                
                // For display, use canvas dimensions
                const imgWidthMm = canvas.width / pixelsPerMm;
                const imgHeightMm = canvas.height / pixelsPerMm;
                
                // Title height in mm (space for graph name at top)
                const titleHeight = 12;
                const margin = 3; // Small margin on all sides
                const availableWidth = pdfWidth - (margin * 2);
                const availableHeight = pdfHeight - titleHeight - margin;
                
                
                const pdf = new jsPDF({
                    orientation: orientation,
                    unit: 'mm',
                    format: [pdfWidth, pdfHeight]
                });
                
                
                pdf.setFontSize(18);
                pdf.setFont(undefined, 'bold');
                pdf.text(graphName, pdfWidth / 2, 10, { align: 'center' });
                
              
                const graphWidthPx = graphWidthWithPadding; // Already in pixels
                const graphHeightPx = graphHeightWithPadding; // Already in pixels
                
                // Calculate scale based on actual graph dimensions in pixels
                const graphWidthPxMm = graphWidthPx / pixelsPerMm;
                const graphHeightPxMm = graphHeightPx / pixelsPerMm;
                
                const widthRatio = availableWidth / graphWidthPxMm;
                const heightRatio = availableHeight / graphHeightPxMm;
                
                // Use the smaller ratio to maintain aspect ratio
                const graphScale = Math.min(widthRatio, heightRatio);
                
                // Calculate scaled dimensions based on actual graph size
                const scaledWidth = graphWidthPxMm * graphScale;
                const scaledHeight = graphHeightPxMm * graphScale;
                
                // Calculate if we need multiple pages based on scaled size
                const scaledPagesX = Math.ceil(scaledWidth / availableWidth);
                const scaledPagesY = Math.ceil(scaledHeight / availableHeight);
                
                if (scaledPagesX > 1 || scaledPagesY > 1) {
                    // Multiple pages: split the scaled image across pages
                    for (let pageY = 0; pageY < scaledPagesY; pageY++) {
                        for (let pageX = 0; pageX < scaledPagesX; pageX++) {
                            if (pageX > 0 || pageY > 0) {
                                pdf.addPage([pdfWidth, pdfHeight], orientation);
                                pdf.setFontSize(18);
                                pdf.setFont(undefined, 'bold');
                                pdf.text(graphName, pdfWidth / 2, 10, { align: 'center' });
                            }
                            
                            
                            const pageStartX = pageX * availableWidth;
                            const pageStartY = pageY * availableHeight;
                            const pageEndX = Math.min(pageStartX + availableWidth, scaledWidth);
                            const pageEndY = Math.min(pageStartY + availableHeight, scaledHeight);
                            const pageWidth = pageEndX - pageStartX;
                            const pageHeight = pageEndY - pageStartY;
                            
                            
                            const sourceStartX = (pageStartX / graphScale) * pixelsPerMm;
                            const sourceStartY = (pageStartY / graphScale) * pixelsPerMm;
                            const sourcePageWidth = (pageWidth / graphScale) * pixelsPerMm;
                            const sourcePageHeight = (pageHeight / graphScale) * pixelsPerMm;
                            
                            
                            const pageCanvas = document.createElement('canvas');
                            pageCanvas.width = sourcePageWidth;
                            pageCanvas.height = sourcePageHeight;
                            const ctx = pageCanvas.getContext('2d');
                            ctx.drawImage(canvas, sourceStartX, sourceStartY, sourcePageWidth, sourcePageHeight, 0, 0, sourcePageWidth, sourcePageHeight);
                            
                            const pageImgData = pageCanvas.toDataURL('image/png');
                            
                            // Position the image with margin
                            pdf.addImage(pageImgData, 'PNG', margin + pageStartX - (pageX * availableWidth), titleHeight + pageStartY - (pageY * availableHeight), pageWidth, pageHeight);
                        }
                    }
                } else {
                    // Single page: center the image horizontally and align to title
                    const canvasAspectRatio = canvas.width / canvas.height;
                    
                    // Calculate dimensions that fit in available space
                    // Try width first
                    let finalScaledWidth = availableWidth;
                    let finalScaledHeight = availableWidth / canvasAspectRatio;
                    
                    // If height exceeds available space, use height as limiting factor
                    if (finalScaledHeight > availableHeight) {
                        finalScaledHeight = availableHeight;
                        finalScaledWidth = availableHeight * canvasAspectRatio;
                    }
                    
                    // Center the image
                    const xOffset = margin + (availableWidth - finalScaledWidth) / 2;
                    const yOffset = titleHeight;
                    
                    // Add image maintaining its original canvas aspect ratio (no stretching/distortion)
                    pdf.addImage(imgData, 'PNG', xOffset, yOffset, finalScaledWidth, finalScaledHeight);
                }
                
                
                const filename = (graphName || 'organization-tree').replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.pdf';
                pdf.save(filename);
                
                // Restore cursor
                document.body.style.cursor = originalCursor;
            }).catch(error => {
                
                if (document.body.contains(tempContainer)) {
                    document.body.removeChild(tempContainer);
                }
                console.error('Error exporting to PDF:', error);
                alert('Error exporting to PDF: ' + error.message);
                document.body.style.cursor = originalCursor;
            });
        }

        
        window.onclick = function(event) {
            const modal = document.getElementById('exportModal');
            if (event.target === modal) {
                closeExportModal();
            }
        }
        
        initializeTree(initialData);

    </script>
</body>

</html>

